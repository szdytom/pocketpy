[[{"l":"Welcome to pocketpy","p":["pkpy is a lightweight(~ 15K LOC) Python interpreter for game scripting, built on C++ 17 with STL.","It aims to be an alternative to lua for game scripting, with elegant syntax, powerful features and competitive performance. pkpy is extremely easy to embed via a single header file pocketpy.h, without external dependencies.","Caution: pocketpy should not be your first C++ project. Please learn C++ programming, compiling, linking, and debugging before working with pocketpy. There are many resources for this on the net."]},{"l":"What it looks like"},{"l":"Supported platforms","p":["pkpy should work on any platform with a C++ 17 compiler. These platforms are officially tested.","Windows 64-bit","Linux 64-bit / 32-bit","macOS 64-bit","Android 64-bit / 32-bit","iOS 64-bit","Emscripten 32-bit","Raspberry Pi OS 64-bit"]},{"l":"Star the repo","p":["If you find pkpy useful, consider star this repository(●'◡'●)"]},{"l":"Sponsor this project","p":["You can sponsor this project via these ways.","Github Sponsors","Buy me a coffee","Your sponsorship will help us develop pkpy continuously."]}],[{"l":"Cheatsheet"},{"l":"Basics","p":["Setup pocketpy","Create a python virtual machine","Dispose a python virtual machine","Execute a source string","Evaluate a source string","Compile a source string into a code object","Execute a compiled code object"]},{"l":"Interop with native types","p":["Create primitive objects","Create a tuple object","Create a list object","Create a dict object","Get native types from python objects","Get native types without type checking"]},{"l":"Access python types","p":["Access built-in python types","Access user registered types","Check if an object is a python type","Get the type of a python object","Convert a type object into a type index"]},{"l":"Access attributes","p":["Check an object supports attribute access","Get and set attributes"]},{"l":"Call python functions","p":["Call a function","Call a method","Cache the name of a function or method to avoid string-based lookup"]},{"l":"Special operations","p":["Compare two python objects","Convert a python object to string","Get the string representation of a python object","Get the JSON representation of a python object","Get the hash value of a python object","Get the iterator of a python object","Get the next item of an iterator","Convert a python iterable to a list"]},{"l":"Bindings","p":["Bind a native function","Bind a property"]},{"l":"Modules","p":["Create a source module","Create a native module"]}],[{"l":"Installation","p":["You have two options to integrate pkpy into your project."]},{"l":"Use the single header file","p":["Download the pocketpy.h on our GitHub Release page. And #include it in your project. The header can only be included once."]},{"l":"Use CMake","p":["Clone the whole repository as a submodule into your project, In your CMakelists.txt, add the following lines:","See CMakeLists.txt for details.","It is safe to use main branch in production if CI badge is green."]},{"l":"Compile flags","p":["To compile it with your project, these flags must be set:","--std=c++17 flag must be set","RTTI must be enabled","Exception must be enabled","For MSVC, /utf-8 flag must be set","For emscripten, you must enable exceptions to make pocketpy work properly. See https://emscripten.org/docs/porting/exceptions.html."]},{"l":"Get prebuilt binaries","p":["We have prebuilt binaries, check them out on our GitHub Actions.","You can download an artifact there which contains the following files."]},{"l":"Example"},{"l":"Overview","p":["pkpy's C++ interfaces are organized in an object-oriented way. All classes are located in pkpy namespace.","The most important class is the VM class. A VM instance is a python virtual machine which holds all necessary runtime states, including callstack, modules, variables, etc.","A process can have multiple VM instances. Each VM instance is independent from each other.","Always use C++ new operator to create a VM instance. DO NOT declare it on the stack. It may cause stack overflow.","The constructor can take 1 extra parameters."]},{"i":"vmbool-enable_ostrue","l":"VM(bool enable_os=true)","p":["enable_os, whether to enable OS-related features or not. This setting controls the availability of privileged modules such os io and os as well as builtin function open. It is designed for sandboxing.","When you are done with the VM instance, use delete operator to dispose it."]},{"l":"Hook standard buffer","p":["By default, pkpy outputs all messages and errors to stdout and stderr. You can redirect them to your own buffer by setting vm-_stdout and vm-_stderr.","These two fields are C function pointers with the following signature:","Or you can override these two virtual functions:"]}],[{"l":"Execute Python Code"},{"l":"Simple execution","p":["Once you have a VM instance, you can execute python code by calling exec method."]},{"i":"pyvar-execstr-source-str-filename-compilemode-mode-pyvar-_modulenullptr","l":"PyVar exec(Str source, Str filename, CompileMode mode, PyVar _module=nullptr)","p":["source, the python source code to be executed","filename, the filename of the source code. This is used for error reporting","mode, the compile mode. See below for details","module, the module where the code will be executed. If nullptr, the code will be executed in the __main__ module","exec handles possible exceptions and returns a PyVar. If the execution is not successful, e.g. a syntax error or a runtime exception, the return value will be nullptr.","There are also overloaded versions of exec and eval, which is useful for simple execution:","PyVar exec(Str source)","PyVar eval(Str source)"]},{"l":"Compile mode","p":["The mode parameter controls how the source code is compiled. There are 5 possible values:","EXEC_MODE, this is the default mode. Just do normal execution.","EVAL_MODE, this mode is used for evaluating a single expression. The source should be a single expression. It cannot contain any statements.","REPL_MODE, this mode is used for REPL. It is similar to EXEC_MODE, but generates PRINT_EXPR opcode when necessary.","CELL_MODE, this mode is designed for Jupyter like execution. It is similar to EXEC_MODE, but generates PRINT_EXPR opcode when necessary.","JSON_MODE, this mode is used for JSON parsing. It is similar to EVAL_MODE, but uses a lexing rule designed for JSON."]},{"l":"Fine-grained execution","p":["In some cases, you may want to execute python code in a more fine-grained way. These two methods are provided for this purpose:","CodeObject_ compile(Str source, Str filename, CompileMode mode, bool unknown_global_scope)","PyVar _exec(CodeObject_ co, PyVar _module)","compile compiles the source code into a CodeObject_ instance. Leave unknown_global_scope to false if you don't know what it means.","_exec executes the CodeObject_ instance.","_exec does not handle exceptions, you need to use try..catch manually."]}],[{"l":"Interop with PyVar","p":["In pkpy, any python object is represented by a PyVar."]},{"l":"Create PyVar from C type","p":["A set of overloaded function PyVar py_var(VM* vm, ...) were implemented to create a PyVar from a supported C type.","Assume we have a VM* vm instance. You can create a python int object from a C i64 type:","Each python type has a corresponding C type, for example, int in python is i64 in C. python's list corresponds to List, str corresponds to Str, etc. For strings, we have defined a set of overloaded version including const char*, std::string, std::string_view, Str, etc.","A more complex example is to create a python list. In the following code, we create a list equals to [0, 1, 2, 3].","Please note that std::move is used here to avoid unnecessary copy. Most types have both a rvalue and a lvalue version of py_var function."]},{"l":"Access internal C type of PyVar","p":["A set of template function T py_castT(VM* vm, PyVar obj) were implemented.","The py_cast function will check the type of obj before casting. If the type is not matched, a TypeError will be thrown.","However, this type check has a cost. If you are sure about the type of obj, you can use the underscore version _py_cast to skip the type check.","For complex objects like list, we can use reference cast to avoid unnecessary copy."]},{"l":"Check type of PyVar","p":["Each PyVar has a Type type field to indicate its type. Type is just an integer which is the global index in vm-_all_types.","VM class has a set of predefined Type constants for quick access. They are prefixed by tp_. For example, tp_object(object), tp_int(int), tp_str(str), tp_list(list), etc.","Types are divided into tagged type and non-tagged type.","small int objects are tagged.","Other types are non-tagged type.","To determine whether a PyVar is of a specific type, you can use the following functions:","bool is_type(PyVar obj, Type type)","bool is_int(PyVar obj)","bool is_float(PyVar obj)","bool is_tagged(PyVar obj)","Simply put, is_type is the most general function and can check any types. Other variants are designed for specific types and are faster.","You can also use check_ prefix functions assert the type of a PyVar, which will throw TypeError on failure.","void check_type(PyVar obj, Type type)"]}],[{"l":"Access Attributes"},{"l":"Direct access","p":["Some python objects have an instance dict, a.k.a, __dict__ in cpython. You can use obj-attr() to manipulate the instance dict of an object.","However, you cannot call attr on an object which does not have an instance dict. For example, the int object.","To determine whether an object has instance dict or not, you can use this snippet."]},{"l":"General access","p":["As you can see, direct access does not take care of derived attributes or methods. In most cases, what you need is getattr and setattr. These two methods handle all possible cases."]},{"i":"pyvar-getattrpyvar-obj-strname-name-bool-throw_errtrue","l":"PyVar getattr(PyVar obj, StrName name, bool throw_err=true)","p":["This method is equivalent to getattr in python. If the attribute is not found, it will return nullptr or throw an AttributeError depending on the value of throw_err."]},{"i":"void-setattrpyvar-strname-pyvar","l":"void setattr(PyVar, StrName, PyVar)","p":["This method is equivalent to setattr in python. It raises TypeError if the object does not support attribute assignment."]}],[{"l":"Call Python Function","p":["pkpy uses a variant of the Vectorcall protocol (PEP 590).","You can use call to invoke any python callable object, including functions, methods, classes, etc. For methods, call_method can be used.","PyVar call(PyVar obj, ...)","PyVar call_method(PyVar obj, StrName name, ...)"]},{"l":"Example","p":["Let's create a dict object and set a key-value pair, which equals to the following python snippet.","First, create an empty dict object,","And set a key-value pair,","And get the value,","If you want to call with dynamic number of arguments, you should use vm-vectorcall. This is a low-level, stack-based API.","First push the callable object to the stack.","Push the self object to the stack. If there is no self, push PY_NULL.","Push the arguments to the stack.","Call vm-vectorcall with the number of arguments."]}],[{"l":"Create Modules","p":["Modules are stored in vm-_modules and vm-_lazy_modules. They are both dict-like objects."]},{"l":"Lazy modules","p":["A lazy module is a python source file. It is compiled and executed when it is imported. Use [] operator to add a lazy module."]},{"l":"Native modules","p":["A native module is a module written in c++ or mixed c++/python. Native modules are always compiled and executed when the VM is created.","To creata a native module, use vm-new_module(Str name)."]},{"l":"Module resolution order","p":["When you do import a module, the VM will try to find it in the following order:","Search vm-_modules, if found, return it.","Search vm-_lazy_modules, if found, compile and execute it, then return it.","Try vm-_import_handler."]},{"l":"Customized import handler","p":["You can use vm-_import_handler to provide a custom import handler for the 3rd step."]},{"l":"Import module via cpp","p":["You can use vm-py_import to import a module. This is equivalent to import in python. Return the module object if success."]}],[{"l":"Miscellaneous"},{"l":"The scope lock of gc","p":["Sometimes you need to use the following code to prevent the gc from collecting objects.","The scope lock is required if you create a PyVar and then try to run python-level bytecodes.","For example, you create a temporary object on the stack and then call vm-py_next.","Because users can have an overload of __next__, this call is unsafe. When the vm is running python-level bytecodes, gc may start and delete your temporary object.","The scope lock prevents this from happening."]}],[{"l":"Advanced Config"},{"l":"Enable os-related features","p":["If you want to enable os-related features, you can do this before including pocketpy.h."]},{"l":"Working with multiple threads","p":["pkpy does not support multi-threading. But you can create multiple VM instances and run them in different threads. You can do the following to ensure thread safety for VM instances:"]},{"l":"Full config","p":["You can take a look at include/pocketpy/config.h to see all the available configuration macros."]}],[{"l":"Application Guide","p":["Before starting, please read the Ideas page and choose a project you are interested in. Set up a C++ compiler, clone pocketpy sources from github and try to build. This helps you confirm that your skills and experience match the requirements of the project."]},{"l":"Build guide for beginners","p":["First, you need to install these tools:","Python(>= 3.8), I am sure you already have it.","A C++ compiler, such as GCC, Clang or MSVC. If you are on Linux, gcc and g++ are already installed. If you are on Windows, you can install Visual Studio with C++ development tools.","CMake(>= 3.10), a cross-platform build tool. You can use pip install cmake to install it.","Then, clone pocketpy sources from github and try to build:","If everything goes well, you will get a main executable ( main.exe on Windows) in the root directory of pocketpy. Simply run it and you will enter pocketpy's REPL."]},{"l":"Application guide","p":["Your need to send an email to blueloveth@foxmail.com with the following information:","A brief introduction about yourself, including the most related open sourced project you have worked on before. It is highly recommended to attach your Github profile link.","A technical proposal for the project you are interested in working on, including:","Your understanding of the project.","The technical approach/architecture you will adopt.","The challenges you might face and how you will overcome them.","A timeline for the project, including the milestones and deliverables.","Other information required by the Google Summer of Code program."]},{"l":"Coding style guide","p":["See Coding Style Guide."]},{"l":"Contact us","p":["If you have any questions, you can join our Discord or contact me via email. We are glad to help you with your application."]}],[{"l":"Project Ideas"},{"l":"Implement pybind11 for bindings","p":["Difficulty Level: 5/5 (Hard)","Skill: Advanced C++ with metaprogramming; Python","Project Length: Medium (175 hours)","pocketpy has provided a low-level API for creating bindings. It is fast, lightweight and easy to debug. However, it still requires a lot of boilerplate code to create bindings for complex C++ classes. The community has long expected a high-level API for creating bindings.","pybind11 is the most popular C++ library for creating Python bindings for CPython. A bunch of Python libraries are using it. pybind11 adopts a template metaprogramming approach to automatically generate bindings for C++ classes.","Our goal is to introduce a pybind11 compatible solution to pocketpy as an alternative way to create bindings for functions and classes. You can use C++17 features to implement it, instead of C++ 11 used in pybind11.","See https://github.com/pocketpy/pocketpy/issues/216 for more details."]},{"l":"Add numpy module","p":["Difficulty Level: 4/5 (Intermediate)","Skill: Intermediate C++; Python; Linear Algebra","Project Length: Medium (175 hours)","Though pocketpy is designed for game scripting, some people are using it for scientific computing. It would be nice to have a numpy module in pocketpy.","numpy is a huge project. Our goal is to implement a most commonly used subset of numpy in pocketpy. You can mix C++ and Python code to simplify the overall workloads.","See https://github.com/pocketpy/pocketpy/issues/202 for more details."]}],[{"l":"Write Bindings","p":["In order to use a C/C++ library in python, you need to write bindings for it.","pkpy uses an universal signature to wrap a function pointer as a python function or method that can be called in python code, i.e NativeFuncC.","The first argument is the pointer of VM instance.","The second argument is an array-like object indicates the arguments list. You can use [] operator to get the element and call size() to get the length of the array.","The return value is a PyVar, which should not be nullptr. If there is no return value, return vm-None."]},{"l":"Bind a function or method","p":["Use vm-bind to bind a function or method.","PyVar bind(PyVar, const char* sig, NativeFuncC)","PyVar bind(PyVar, const char* sig, const char* docstring, NativeFuncC)"]},{"l":"How to capture something","p":["By default, the lambda being bound is a C function pointer, you cannot capture anything! The following example does not compile.","I do not encourage you to capture something in a lambda being bound because:","Captured lambda runs slower and causes \"code-bloat\".","Captured values are unsafe, especially for PyVar as they could leak by accident.","However, there are 3 ways to capture something when you really need to. The most safe and elegant way is to subclass VM and add a member variable.","The 2nd way is to use vm-bind's last parameter userdata, you can store an pkpy::any object. And use lambda_get_userdataT(args.begin()) to get it inside the lambda body.","The 3rd way is to change the macro PK_ENABLE_STD_FUNCTION in config.h:","Then you can use standard capture list in lambda."]},{"l":"Bind a class or struct","p":["Assume you have a struct Point declared as follows.","You can create a test module and use vm-register_user_class to bind the class to the test module."]},{"l":"Handle gc for container types","p":["If your custom type stores PyVar in its fields, you need to handle gc for them.","Add a magic method _gc_mark() const to your custom type.","For global objects, use the callback in vm-heap.","It will be invoked before a GC starts. So you can mark objects inside the callback to keep them alive."]},{"l":"Others","p":["For some magic methods, we provide specialized binding function. They do not take universal function pointer as argument. You need to provide the detailed Type object and the corresponding function pointer.","This specialized binding function has optimizations and result in better performance when calling from python code.","For example, vm-bind__add__ is preferred over vm-bind_func(type, __add__, 2, f_add)."]},{"l":"Further reading","p":["See random.cpp for an example used by random module.","See collections.cpp for a modern implementation of collections.deque."]},{"l":"Reuse Lua bindings","p":["pkpy provides a lua bridge to reuse lua bindings. It allows you to run lua code and call lua functions in python by embedding a lua virtual machine.","Add lua_bridge.hpp and lua_bridge.cpp in 3rd/lua_bridge to your project. Make sure lua.h, lualib.h and lauxlib.h are in your include path because lua_bridge.hpp needs them.","The lua bridge is based on lua 5.1.5 for maximum compatibility. lua 5.2 or higher should also work."]},{"l":"Setup","p":["Allow create in Python?","bool","boolean","dict","float","function","int","list","Lua type","lua.Function","lua.Table","nil","NO","None","number","Only basic types can be passed between python and lua. The following table shows the type mapping. If you pass an unsupported type, an exception will be raised.","Python type","Reference?","str","string","table","tuple","Use initialize_lua_bridge(VM*, lua_State*) to initialize the lua bridge. This creates a new module lua in your python virtual machine.","YES","You can use lua.dostring to execute lua code and get the result. And use lua.Table() to create a lua table. A lua.Table instance in python is a dict-like object which provides a bunch of magic methods to access the underlying lua table."]},{"l":"Example"}],[{"l":"Basic Features","p":["(1, 2, 'a')","[1, 2, 'a']","[i for i in range(5)]","{'a': 1, 'b': 2}","@cache","a, *b = [1, 2, 3]","a, b = 1, 2","a[1:2], a[:2], a[1:]","Check this Cheatsheet for a quick overview of the supported features.","class A(B):","Context Block","Decorator","def f(a:int, b:float=1)","def f(x,*args,y=1):","Dict","Dynamic Code","eval()/exec()","Example","Exception","F-String","f'value is {x}'","for/while/break/continue","Function","Generator","hasattr()/getattr()/setattr()","If Else","if..else..elif","Import","import/from..import","List","ListComp","Loop","Name","raise/try..catch..finally","Reflection","Slice","Star Unpacking","Subclass","Supported","The following table shows the basic features of pkpy with respect to cpython. The features marked with YES are supported, and the features marked with NO are not supported.","Tuple","Type Annotation","Unpacking","with expr as id:","YES","yield i"]},{"l":"Supported magic methods"},{"l":"Unary operators","p":["__repr__","__str__","__hash__","__len__","__iter__","__next__","__neg__"]},{"l":"Logical operators","p":["__eq__","__lt__","__le__","__gt__","__ge__","__contains__"]},{"l":"Binary operators","p":["__add__","__and__","__floordiv__","__invert__","__lshift__","__matmul__","__mod__","__mul__","__or__","__pow__","__radd__","__rmul__","__rshift__","__rsub__","__sub__","__truediv__","__xor__"]},{"l":"Indexer","p":["__getitem__","__setitem__","__delitem__"]},{"l":"Specials","p":["__new__","__init__","__call__","__divmod__","__enter__","__exit__","__name__","__all__"]}],[{"l":"Comparison with CPython","p":["cpython is the reference implementation of the Python programming language. It is written in C and is the most widely used implementation of Python."]},{"l":"The design goal","p":["pkpy aims to be an alternative to lua for game scripting, not cpython for general purpose programming.","For syntax and semantics, pkpy is designed to be as close to cpython as possible.","For ecosystem and others, pkpy is not compatible with cpython.","pkpy supports most of the syntax and semantics of python. For performance and simplicity, some features are not implemented, or behave differently. The easiest way to test a feature is to try it on your browser."]},{"l":"Unimplemented features","p":["Descriptor protocol __get__ and __set__. However, @property is implemented.","__slots__ in class definition.","else clause in try..except.","Inplace methods like __iadd__ and __imul__.","__del__ in class definition.","Multiple inheritance."]},{"l":"Different behaviors","p":["positional and keyword arguments are strictly evaluated.","++i and --j is an increment/decrement statement, not an expression.","int does not derive from bool.","int is 64-bit. You can use long type explicitly for arbitrary sized integers.","__ne__ is not required. Define __eq__ is enough.","Raw string cannot have boundary quotes in it, even escaped. See #55.","In a starred unpacked assignment, e.g. a, b, *c = x, the starred variable can only be presented in the last position. a, *b, c = x is not supported.","A Tab is equivalent to 4 spaces. You can mix Tab and spaces in indentation, but it is not recommended.","%, , //, ^ and | for int behave the same as C, not python.","str.split and str.splitlines will remove all empty entries.","__getattr__, __setattr__ and __delattr__ can only be set in cpp."]}],[{"l":"Arbitrary Sized Integers","p":["Unlike cpython, pkpy's int is of limited precision (64-bit).","For arbitrary sized integers, we provide a builtin long type, just like python2's long. long is implemented via pure python in _long.py."]},{"l":"Create a long object","p":["You can use L suffix to create a long literal from a decimal literal. Also, you can use long() function to create a long object from a int object or a str object."]}],[{"l":"Debugging","p":["This feature is available in v1.4.5 or higher. Set PK_ENABLE_PROFILER to 1 to enable this feature.","You can invoke breakpoint() in your python code to start a PDB-like session.","The following commands are supported:","h, help: show this help message","q, quit: exit the debugger","n, next: execute next line","s, step: step into","w, where: show current stack frame","c, continue: continue execution","a, args: show local variables","l, list: show lines around current line","ll, longlist: show all lines","p, print expr: evaluate expression","!, execute statement: execute statement"]}],[{"l":"Goto Statement","p":["pkpy supports goto/label just like C. You are allowed to change the control flow unconditionally."]},{"l":"Define a label"},{"l":"Goto a label"},{"l":"Example"}],[{"l":"Increment Statement","p":["pkpy provides ++i and --j statements to operate a simple named int variable.","++i is equivalent to i+=1, but much faster","--j is equivalent to j-=1, but much faster"]},{"l":"Example"}],[{"l":"Precompiling","p":["pkpy allows you to precompile python code into two special forms, which can be executed later."]},{"l":"In-memory precompilation","p":["You can use vm-compile to compile your source code into a CodeObject_ object. This object can be executed later by vm-_exec.","This CodeObject_ object is a very non-generic form of the compiled code, which is an in-memory form. Very efficient, but not portable. You are not able to save it to a file or load it from a file."]},{"l":"String precompilation","p":["In order to save the compiled code to a file, you need to use vm-precompile. It does some basic preprocessing and outputs the result as a human-readable string.","You can also use python's compile function to achieve the same effect.","Let's take a look at the precompiled string.","Comparing with In-memory precompilation, String precompilation drops most of the information of the original source code. It has an encryption effect, which can protect your source code from being stolen. This also means there is no source line information when an error occurs.","You will get this (without source line information):","instead of this (with source line information):","String compilation has no guarantee of compatibility between different versions of pkpy.","You can use this snippet to convert every python file in a directory into precompiled strings."]}],[{"l":"Undefined Behaviour","p":["These are the undefined behaviours of pkpy. The behaviour of pkpy is undefined if you do the following things.","Delete a builtin object. For example, del int.__add__.","Call an unbound method with the wrong type of self. For example, int.__add__('1', 2).","Type T's __new__ returns an object that is not an instance of T.","Call __new__ with a type that is not a subclass of type.","__eq__, __lt__ or __contains__, etc.. returns a value that is not a boolean."]}],[{"l":"array2d","p":["Efficient general-purpose 2D array.","https://github.com/pocketpy/pocketpy/blob/main/include/typings/array2d.pyi"]},{"l":"Example"}],[{"l":"base64"},{"i":"base64b64encodeb-bytes---bytes","l":"base64.b64encode(b: bytes) - bytes","p":["Encode bytes-like object b using the standard Base64 alphabet."]},{"i":"base64b64decodeb-bytes---bytes","l":"base64.b64decode(b: bytes) - bytes","p":["Decode Base64 encoded bytes-like object b."]}],[{"l":"bisect"},{"i":"bisectbisect_lefta-x","l":"bisect.bisect_left(a, x)","p":["Return the index where to insert item x in list a, assuming a is sorted."]},{"i":"bisectbisect_righta-x","l":"bisect.bisect_right(a, x)","p":["Return the index where to insert item x in list a, assuming a is sorted."]},{"i":"bisectinsort_lefta-x","l":"bisect.insort_left(a, x)","p":["Insert item x in list a, and keep it sorted assuming a is sorted.","If x is already in a, insert it to the left of the leftmost x."]},{"i":"bisectinsort_righta-x","l":"bisect.insort_right(a, x)","p":["Insert item x in list a, and keep it sorted assuming a is sorted.","If x is already in a, insert it to the right of the rightmost x."]}],[{"l":"c","p":["Interop with pointers and C structs.","https://github.com/pocketpy/pocketpy/blob/main/include/typings/c.pyi"]}],[{"l":"cmath","p":["This module is experimental and may have bugs or other issues.","Mathematical functions for complex numbers.","https://docs.python.org/3/library/cmath.html"]}],[{"l":"collections"},{"i":"collectionscounteriterable","l":"collections.Counter(iterable)","p":["Return a dict containing the counts of each element in iterable."]},{"i":"collectionsdeque","l":"collections.deque","p":["A double-ended queue."]},{"i":"collectionsdefaultdict","l":"collections.defaultdict","p":["A dictionary that returns a default value when a key is not found."]}],[{"l":"colorsys","p":["The same as the standard library module colorsys in python 3.11.","https://github.com/python/cpython/blob/3.11/Lib/colorsys.py"]}],[{"l":"csv"},{"i":"csvreadercsvfile-liststr---listlist","l":"csv.reader(csvfile: list[str]) - list[list]","p":["Parse a CSV file into a list of lists."]},{"i":"csvdictreadercsvfile-liststr---listdict","l":"csv.DictReader(csvfile: list[str]) - list[dict]","p":["Parse a CSV file into a list of dictionaries."]},{"l":"Example"}],[{"l":"dataclasses"},{"i":"dataclassesdataclass","l":"dataclasses.dataclass","p":["A decorator that is used to add generated special method to classes, including __init__, __repr__ and __eq__."]},{"i":"dataclassesasdictobj---dict","l":"dataclasses.asdict(obj) - dict","p":["Convert a dataclass instance to a dictionary."]}],[{"l":"datetime"},{"i":"datetimenow","l":"datetime.now()","p":["Returns the current date and time as a datetime object."]},{"i":"datetoday","l":"date.today()","p":["Returns the current local date as a date object."]}],[{"l":"easing","p":["easing.InBack(t: float) - float","easing.InBounce(t: float) - float","easing.InCirc(t: float) - float","easing.InCubic(t: float) - float","easing.InElastic(t: float) - float","easing.InExpo(t: float) - float","easing.InOutBack(t: float) - float","easing.InOutBounce(t: float) - float","easing.InOutCirc(t: float) - float","easing.InOutCubic(t: float) - float","easing.InOutElastic(t: float) - float","easing.InOutExpo(t: float) - float","easing.InOutQuad(t: float) - float","easing.InOutQuart(t: float) - float","easing.InOutQuint(t: float) - float","easing.InOutSine(t: float) - float","easing.InQuad(t: float) - float","easing.InQuart(t: float) - float","easing.InQuint(t: float) - float","easing.InSine(t: float) - float","easing.Linear(t: float) - float","easing.OutBack(t: float) - float","easing.OutBounce(t: float) - float","easing.OutCirc(t: float) - float","easing.OutCubic(t: float) - float","easing.OutElastic(t: float) - float","easing.OutExpo(t: float) - float","easing.OutQuad(t: float) - float","easing.OutQuart(t: float) - float","easing.OutQuint(t: float) - float","easing.OutSine(t: float) - float","Python wrapper for easing functions."]}],[{"l":"enum"},{"i":"enumenum","l":"enum.Enum","p":["Base class for creating enumerated constants.","Example:"]}],[{"l":"functools"},{"i":"functoolscache","l":"functools.cache","p":["A decorator that caches a function's return value each time it is called. If called later with the same arguments, the cached value is returned, and not re-evaluated."]},{"i":"functoolsreducefunction-sequence-initial","l":"functools.reduce(function, sequence, initial=...)","p":["Apply a function of two arguments cumulatively to the items of a sequence, from left to right, so as to reduce the sequence to a single value. For example, functools.reduce(lambda x, y: x+y, [1, 2, 3, 4, 5]) calculates ((((1+2)+3)+4)+5). The left argument, x, is the accumulated value and the right argument, y, is the update value from the sequence. If the optional initial is present, it is placed before the items of the sequence in the calculation, and serves as a default when the sequence is empty."]},{"i":"functoolspartialf-args-kwargs","l":"functools.partial(f, *args, **kwargs)","p":["Return a new partial object which when called will behave like f called with the positional arguments args and keyword arguments kwargs. If more arguments are supplied to the call, they are appended to args. If additional keyword arguments are supplied, they extend and override kwargs."]}],[{"l":"gc"},{"i":"gccollect","l":"gc.collect()","p":["Invoke the garbage collector."]}],[{"l":"heapq"},{"i":"heapqheappushheap-item","l":"heapq.heappush(heap, item)","p":["Push the value item onto the heap, maintaining the heap invariant."]},{"i":"heapqheappopheap","l":"heapq.heappop(heap)","p":["Pop and return the smallest item from the heap, maintaining the heap invariant. If the heap is empty, IndexError is raised. To access the smallest item without popping it, use heap[0]."]},{"i":"heapqheapifyx","l":"heapq.heapify(x)","p":["Transform list x into a heap, in-place, in linear time."]},{"i":"heapqheappushpopheap-item","l":"heapq.heappushpop(heap, item)","p":["Push item on the heap, then pop and return the smallest item from the heap. The combined action runs more efficiently than heappush() followed by a separate heappop()."]},{"i":"heapqheapreplaceheap-item","l":"heapq.heapreplace(heap, item)","p":["Pop and return the smallest item from the heap, and also push the new item. The heap size doesn’t change. If the heap is empty, IndexError is raised."]}],[{"l":"io","p":["This module is optional. Set PK_ENABLE_OS to 1 to enable it."]},{"i":"iofileioreadsize-1---bytes--str","l":"io.FileIO.read(size=-1) - bytes | str","p":["Read up to size bytes from the file. If size is negative or omitted, read until EOF."]},{"i":"iofileiowritedata-bytes--str","l":"io.FileIO.write(data: bytes | str)","p":["Write the given data to the file."]},{"i":"iofileioseekoffset-whence0---int","l":"io.FileIO.seek(offset, whence=0) - int","p":["Change the file position to the given offset. The whence argument is optional and defaults to 0(absolute file positioning); other values are 1(seek relative to the current position) and 2(seek relative to the file's end)."]},{"i":"iofileiotell---int","l":"io.FileIO.tell() - int","p":["Return the current file position."]},{"i":"iofileioclose","l":"io.FileIO.close()","p":["Close the file."]},{"i":"ioseek_set","l":"io.SEEK_SET","p":["Seek from the beginning of the file."]},{"i":"ioseek_cur","l":"io.SEEK_CUR","p":["Seek from the current position."]},{"i":"ioseek_end","l":"io.SEEK_END","p":["Seek from the end of the file."]}],[{"l":"itertools"},{"i":"itertoolszip_longesta-b","l":"itertools.zip_longest(a, b)","p":["Returns an iterator that aggregates elements from the input iterables. If the input iterables are of different lengths, missing values are filled-in with None."]}],[{"l":"json","p":["pkpy has two JSON modules.","The built-in JSON module is always available and can be imported via import json.","After v1.2.7, you can set PK_USE_CJSON to ON in CMakeLists.txt to enable an alternative JSON module cjson.","Their interfaces are the same. cjson is faster while the built-in json is more stable since it was developed earlier."]},{"i":"jsonloadsdata-str--bytes","l":"json.loads(data: str | bytes)","p":["Decode a JSON string into a python object."]},{"i":"jsondumpsobj---str","l":"json.dumps(obj) - str","p":["Encode a python object into a JSON string."]}],[{"l":"linalg","p":["Provide mat3x3, vec2, vec3 and vec4 types.","This classes adopt torch's naming convention. Methods with _ suffix will modify the instance itself.","https://github.com/pocketpy/pocketpy/blob/main/include/typings/linalg.pyi"]}],[{"l":"line_profiler","p":["This module is optional. Set PK_ENABLE_PROFILER to 1 to enable it."]},{"l":"Example"}],[{"l":"math"},{"i":"mathpi","l":"math.pi","p":["3.141592653589793"]},{"i":"mathe","l":"math.e","p":["2.718281828459045"]},{"i":"mathinf","l":"math.inf","p":["The inf."]},{"i":"mathnan","l":"math.nan","p":["The nan."]},{"i":"mathceilx","l":"math.ceil(x)","p":["Return the ceiling of x as a float, the smallest integer value greater than or equal to x."]},{"i":"mathfabsx","l":"math.fabs(x)","p":["Return the absolute value of x."]},{"i":"mathfloorx","l":"math.floor(x)","p":["Return the floor of x as a float, the largest integer value less than or equal to x."]},{"i":"mathfsumiterable","l":"math.fsum(iterable)","p":["Return an accurate floating point sum of values in the iterable. Avoids loss of precision by tracking multiple intermediate partial sums:"]},{"i":"mathgcda-b","l":"math.gcd(a, b)","p":["Return the greatest common divisor of the integers a and b."]},{"i":"mathisfinitex","l":"math.isfinite(x)","p":["Return True if x is neither an infinity nor a NaN, and False otherwise."]},{"i":"mathisinfx","l":"math.isinf(x)","p":["Return True if x is a positive or negative infinity, and False otherwise."]},{"i":"mathisnanx","l":"math.isnan(x)","p":["Return True if x is a NaN (not a number), and False otherwise."]},{"i":"mathisclosea-b","l":"math.isclose(a, b)","p":["Return True if the values a and b are close to each other and False otherwise."]},{"i":"mathexpx","l":"math.exp(x)","p":["Return e raised to the power of x."]},{"i":"mathlogx","l":"math.log(x)","p":["Return the natural logarithm of x(to base e)."]},{"i":"mathlog2x","l":"math.log2(x)","p":["Return the base-2 logarithm of x. This is usually more accurate than log(x, 2)."]},{"i":"mathlog10x","l":"math.log10(x)","p":["Return the base-10 logarithm of x. This is usually more accurate than log(x, 10)."]},{"i":"mathpowx-y","l":"math.pow(x, y)","p":["Return x raised to the power y."]},{"i":"mathsqrtx","l":"math.sqrt(x)","p":["Return the square root of x."]},{"i":"mathacosx","l":"math.acos(x)","p":["Return the arc cosine of x, in radians."]},{"i":"mathasinx","l":"math.asin(x)","p":["Return the arc sine of x, in radians."]},{"i":"mathatanx","l":"math.atan(x)","p":["Return the arc tangent of x, in radians."]},{"i":"mathatan2y-x","l":"math.atan2(y, x)","p":["Return atan(y / x), in radians. The result is between -pi and pi. The vector in the plane from the origin to point (x, y) makes this angle with the positive X axis. The point of atan2() is that the signs of both inputs are known to it, so it can compute the correct quadrant for the angle. For example, atan(1) and atan2(1, 1) are both pi/4, but atan2(-1, -1) is -3*pi/4."]},{"i":"mathcosx","l":"math.cos(x)","p":["Return the cosine of x radians."]},{"i":"mathsinx","l":"math.sin(x)","p":["Return the sine of x radians."]},{"i":"mathtanx","l":"math.tan(x)","p":["Return the tangent of x radians."]},{"i":"mathdegreesx","l":"math.degrees(x)","p":["Convert angle x from radians to degrees."]},{"i":"mathradiansx","l":"math.radians(x)","p":["Convert angle x from degrees to radians."]},{"i":"mathmodfx","l":"math.modf(x)","p":["Return the fractional and integer parts of x. Both results carry the sign of x and are floats."]},{"i":"mathfactorialx","l":"math.factorial(x)","p":["Return x factorial as an integer."]}],[{"l":"operator","p":["The operator module exports a set of efficient functions corresponding to the intrinsic operators of Python. For example, operator.add(x, y) is equivalent to the expression x+y. Many function names are those used for special methods, without the double underscores."]},{"l":"Mapping Operators to Functions","p":["-a","~a","a - b","a != b","a @ b","a * b","a ** b","a / b","a // b","a % b","a ^ b","a + b","a = b","a == b","a | b","a b","a is b","a is not b","a[b]","a[b] = c","add(a, b)","Addition","and_(a, b)","b in a","Bitwise AND","Bitwise Inversion","Bitwise OR","Bitwise XOR","bool(a)","Containment Test","contains(a, b)","del a[b]","delitem(a, b)","Division","eq(a, b)","Equality","Exponentiation","floordiv(a, b)","Function","ge(a, b)","getitem(a, b)","gt(a, b)","Identity","Index Assignment","Index Deletion","Indexing","invert(a)","is_(a, b)","is_not(a, b)","le(a, b)","Left Shift","lshift(a, b)","lt(a, b)","matmul(a, b)","Matrix Multiplication","mod(a, b)","Modulo","mul(a, b)","Multiplication","ne(a, b)","neg(a)","Negation (Arithmetic)","Negation (Logical)","not a","not_(a)","Operation","or_(a, b)","Ordering","pow(a, b)","Right Shift","rshift(a, b)","setitem(a, b, c)","sub(a, b)","Subtraction","Syntax","truediv(a, b)","Truth Test","truth(a)","xor(a, b)"]},{"l":"In-place Operators","p":["a -= b","a *= b","a //= b","a /= b","a %= b","a ^= b","a += b","a = b","a |= b","Addition","Bitwise AND","Bitwise OR","Bitwise XOR","Division","Function","iadd(a, b)","iand(a, b)","ifloordiv(a, b)","ilshift(a, b)","imod(a, b)","imul(a, b)","ior(a, b)","irshift(a, b)","isub(a, b)","itruediv(a, b)","ixor(a, b)","Left Shift","Modulo","Multiplication","Operation","Right Shift","Subtraction","Syntax"]}],[{"l":"os","p":["This module is optional. Set PK_ENABLE_OS to 1 to enable it."]},{"i":"osgetcwd","l":"os.getcwd()","p":["Returns the current working directory."]},{"i":"oschdirpath-str","l":"os.chdir(path: str)","p":["Changes the current working directory to the given path."]},{"i":"oslistdirpath-str","l":"os.listdir(path: str)","p":["Returns a list of files and directories in the given path."]},{"i":"osremovepath-str","l":"os.remove(path: str)","p":["Removes the file at the given path."]},{"i":"osmkdirpath-str","l":"os.mkdir(path: str)","p":["Creates a directory at the given path."]},{"i":"osrmdirpath-str","l":"os.rmdir(path: str)","p":["Removes the directory at the given path."]},{"i":"ospathjoinpaths-str","l":"os.path.join(*paths: str)","p":["Joins the given paths together."]},{"i":"ospathexistspath-str","l":"os.path.exists(path: str)","p":["Check if the given path exists."]},{"i":"ospathbasenamepath-str","l":"os.path.basename(path: str)","p":["Returns the basename of the given path."]},{"i":"ospathisdirpath-str","l":"os.path.isdir(path: str)","p":["Check if the given path is a directory."]},{"i":"ospathisfilepath-str","l":"os.path.isfile(path: str)","p":["Check if the given path is a file."]},{"i":"ospathabspathpath-str","l":"os.path.abspath(path: str)","p":["Returns the absolute path of the given path."]},{"l":"Other functions","p":["You can add other functions to os module via normal binding if you need them. For example, add os.system:"]}],[{"l":"pickle"},{"i":"pickledumpsobj---bytes","l":"pickle.dumps(obj) - bytes","p":["Return the pickled representation of an object as a bytes object."]},{"i":"pickleloadsb-bytes","l":"pickle.loads(b: bytes)","p":["Return the unpickled object from a bytes object."]},{"i":"what-can-be-pickled-and-unpickled","l":"What can be pickled and unpickled?","p":["The following types can be pickled:","None, True, and False;","integers, floating-point numbers;","strings, bytes;","tuples, lists, sets, and dictionaries containing only picklable objects;","functions (built-in and user-defined) accessible from the top level of a module (using def, not lambda);","classes accessible from the top level of a module;","instances of such classes","PY_STRUCT_LIKE objects","The following magic methods are available:","__getnewargs__","__getstate__","__setstate__","__reduce__"]}],[{"l":"random"},{"i":"randomseeda","l":"random.seed(a)","p":["Set the random seed."]},{"i":"randomrandom","l":"random.random()","p":["Return a random float number in the range [0.0, 1.0)."]},{"i":"randomrandinta-b","l":"random.randint(a, b)","p":["Return a random integer in the range [a, b]."]},{"i":"randomuniforma-b","l":"random.uniform(a, b)","p":["Return a random float number in the range [a, b)."]},{"i":"randomchoiceseq","l":"random.choice(seq)","p":["Return a random element from a sequence."]},{"i":"randomshuffleseq","l":"random.shuffle(seq)","p":["Shuffle a sequence inplace."]},{"i":"randomchoicespopulation-weightsnone-k1","l":"random.choices(population, weights=None, k=1)","p":["Return a k sized list of elements chosen from the population with replacement."]}],[{"l":"sys"},{"i":"sysversion","l":"sys.version","p":["The version of pkpy."]},{"i":"sysplatform","l":"sys.platform","p":["May be one of:","win32","linux","darwin","android","ios","emscripten"]},{"i":"sysargv","l":"sys.argv","p":["The command line arguments. Set by vm-set_main_argv."]}],[{"l":"time"},{"i":"timetime","l":"time.time()","p":["Returns the current time in seconds since the epoch as a floating point number."]},{"i":"timesleepsecs","l":"time.sleep(secs)","p":["Suspend execution of the calling thread for the given number of seconds."]},{"i":"timelocaltime","l":"time.localtime()","p":["Returns the current struct time as a struct_time object."]}],[{"l":"traceback"},{"i":"tracebackprint_exc---none","l":"traceback.print_exc() - None","p":["Print the last exception and its traceback."]},{"i":"tracebackformat_exc---str","l":"traceback.format_exc() - str","p":["Return the last exception and its traceback as a string."]}],[{"l":"typing","p":["Placeholder module for type hints."]}],[{"l":"References","p":["This page contains all useful methods of VM class."]},{"l":"Python Equivalents"},{"l":"Utility Methods"},{"l":"Name Lookup Methods"},{"l":"Source Execution Methods"},{"l":"Invocation Methods"},{"l":"Logging Methods"},{"l":"Magic Bindings"},{"l":"General Bindings"},{"l":"Error Reporting Methods"},{"l":"Type Checking Methods"},{"l":"User Type Registration"}],[{"l":"Introduction"},{"l":"What C-API is for","p":["If your target platform does not support C++ 17. You can compile pkpy into a static library and use its exported C-APIs.","Our C-APIs take a lot of inspiration from the lua C-APIs. Methods return a bool indicating if the operation succeeded or not. Special thanks for @koltenpearson's contribution.","C-APIs are always stable and backward compatible."]},{"l":"Basic functions","p":["pkpy_vm* pkpy_new_vm(bool enable_os)","Wraps new VM(enable_os) in C++.","void pkpy_delete_vm(pkpy_vm*)","Wraps delete vm in C++.","bool pkpy_exec(pkpy_vm*, const char* source)","Wraps vm-exec. Execute a string of source code.","bool pkpy_exec_2(pkpy_vm*, const char* source, const char* filename, int mode, const char* module)","Wraps vm-exec_2. Execute a string of source code with more options.","void pkpy_set_main_argv(pkpy_vm*, int argc, char** argv)","Wraps vm-set_main_argv. Set the sys.argv before executing scripts."]}],[{"l":"Stack Manipulation"},{"l":"Basic manipulation","p":["bool pkpy_dup(pkpy_vm*, int)","Duplicate the value at the given index.","bool pkpy_pop(pkpy_vm*, int)","Pop n values from the stack.","bool pkpy_pop_top(pkpy_vm*)","Pop the top value from the stack.","bool pkpy_dup_top(pkpy_vm*)","Duplicate the top value on the stack.","bool pkpy_rot_two(pkpy_vm*)","Swap the top two values on the stack.","int pkpy_stack_size(pkpy_vm*)","Get the element count of the stack."]},{"i":"basic-push-check-and-convert","l":"Basic push, check and convert","p":["pkpy_push_xxx pushes a value onto the stack.","pkpy_is_xxx checks if the value at the given index is of the given type.","pkpy_to_xxx converts the value at the given index to the given type.","Stack index is 0-based instead of 1-based. And it can be negative, which means the index is counted from the top of the stack."]},{"l":"Special push","p":["pkpy_push_null(pkpy_vm*)","Push a PY_NULL onto the stack. It is used for pkpy_vectorcall.","pkpy_push_function(pkpy_vm*, const char* sig, pkpy_CFunction f)","Push a function onto the stack. sig is the function signature, e.g. add(a: int, b: int) - int. f is the function pointer.","pkpy_push_module(pkpy_vm*, const char* name)","Push a new module onto the stack. name is the module name. This is not import. It creates a new module object."]},{"l":"Variable access","p":["bool pkpy_eval(pkpy_vm*, const char* source)","bool pkpy_get_unbound_method(pkpy_vm*, pkpy_CName name)","bool pkpy_getattr(pkpy_vm*, pkpy_CName name)","bool pkpy_getglobal(pkpy_vm*, pkpy_CName name)","bool pkpy_py_repr(pkpy_vm*)","bool pkpy_setattr(pkpy_vm*, pkpy_CName name)","bool pkpy_setglobal(pkpy_vm*, pkpy_CName name)","bool pkpy_unpack_sequence(pkpy_vm*, int size)","Evaluate a string and push the result onto the stack.","Get the repr of the value at the top of the stack.","It is used for method call. Get an unbound method from the object at the top of the stack. name is the method name. Also push the object as self.","Push a global/builtin variable onto the stack. Return false if the variable is not found.","Push b.name onto the stack. Return false if the attribute is not found.","Set a global variable to the value at the top of the stack.","Set b.name to the value at the top of the stack. First push the value, then push b.","Unpack a sequence at the top of the stack. size is the element count of the sequence."]}],[{"l":"Call"},{"i":"bool-pkpy_vectorcallpkpy_vm-int-argc","l":"bool pkpy_vectorcall(pkpy_vm*, int argc)","p":["Wraps vm-vectorcall(argc). This function is used to call a function with a fixed number of arguments. The arguments are popped from the stack. The return value is pushed onto the stack.","First push the function to call.","Push self argument if it is a method call. Otherwise, call pkpy_push_null.","Push arguments from left to right.","Unlike lua, a python function always returns a value. If the function returns void, it will push None onto the stack. You can call pkpy_pop_top to discard the return value."]}],[{"l":"Specials","p":["void pkpy_free(void* p)","Wraps free(p) in C++.","pkpy_CString pkpy_string(const char*)","Construct a pkpy_CString from a null-terminated C string.","pkpy_CName pkpy_name(const char*)","Construct a pkpy_CName from a null-terminated C string. You should cache the result of this function if you are going to use it multiple times.","pkpy_CString pkpy_name_to_string(pkpy_CName)","Convert a pkpy_CName to a pkpy_CString."]}],[{"l":"Error Handling"},{"i":"bool-pkpy_clear_errorpkpy_vm-char-message","l":"bool pkpy_clear_error(pkpy_vm*, char** message)","p":["If a method returns false, call the pkpy_clear_error method to check the error and clear it","If pkpy_clear_error returns false, it means that no error was set, and it takes no action","If pkpy_clear_error returns true, it means there was an error and it was cleared. It will provide a string summary of the error in the message parameter if it is not NULL.","You are responsible for freeing message."]},{"i":"bool-pkpy_check_errorpkpy_vm","l":"bool pkpy_check_error(pkpy_vm*)","p":["Return true if the vm is currently in an error state."]},{"i":"bool-pkpy_errorpkpy_vm-const-char-name-pkpy_cstring-message","l":"bool pkpy_error(pkpy_vm*, const char* name, pkpy_CString message)","p":["Set the error state of the vm. It is almost equivalent to raise in python."]}],[{"l":"Coding Style Guide"},{"l":"For Python","p":["Use PEP-8 as the coding style guide."]},{"i":"for-c","l":"For C++"},{"l":"Naming rules","p":["For class names, always use PascalCase","For function and methods, use snake_case","For special python objects, use the same name as in python.","For global constants, use k prefix with PascalCase","For macros, use SNAKE_CASE"]},{"l":"Access control","p":["Please use python style access control.","We do not recommend to use C++ keywords such as private or public to achieve access control. Also do not write any trivial setter/getter.","Use a single _ as prefix to indicate a function or variable is for internal use.","_ prefix is just a warning to remind you to use such members carefully.","It does not forbid users to access internal members."]},{"l":"Use compact style","p":["Try to make the code compact if it does not affect readability."]},{"i":"for-stdshared_ptrt","l":"For std::shared_ptrT","p":["Use a _ suffix to indicate a type is a shared pointer."]}],[{"l":"Performance","p":["Currently, pkpy is as fast as cpython 3.9. Performance results for cpython 3.9 are applicable to for pkpy.","Here is a benchmark result of v1.2.6. Files are located in benchmarks/."]},{"l":"win32 64-bit cpy39"},{"l":"linux 64-bit cpy38"},{"l":"linux 32-bit cpy39","p":["See actions/runs."]},{"l":"Primes benchmarks","p":["0.104s ■□□□□□□□□□□□□□□□","1.2.7","1.576s ■■■■■■■■■□□□□□□□","2.385s ■■■■■■■■■■■■■□□□","2.871s ■■■■■■■■■■■■■■■■","3.8.10","5.3.3","benchmarks/primes.cpp","benchmarks/primes.lua","benchmarks/primes.py","c++","cpython","file","gnu++ 11","lua","name","pkpy","These are the results of the primes benchmark on Intel i5-12400F, WSL (Ubuntu 20.04 LTS).","time","version"]}],[{"l":"License","p":["pkpy is licensed under the MIT License."]}]]